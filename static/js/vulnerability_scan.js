/**
 * CyberTech - Cybersecurity Breach Detection System
 * Vulnerability Scanning JavaScript file
 * Copyright Simbarashe Chimbera
 */

document.addEventListener('DOMContentLoaded', function() {
    // Initialize vulnerability scan form
    initVulnerabilityScanForm();
    
    // Initialize vulnerability management UI
    initVulnerabilityManagement();
    
    // Initialize scan result filters
    initVulnerabilityFilters();
    
    // Initialize vulnerability visualization
    initVulnerabilityVisualization();
});

// Initialize vulnerability scan form with validation
function initVulnerabilityScanForm() {
    const form = document.getElementById('vulnerability-scan-form');
    if (!form) return;
    
    // Scan depth selection change handler
    const scanDepthSelect = form.querySelector('#scan_depth');
    if (scanDepthSelect) {
        const depthInfo = document.getElementById('depth-info');
        
        scanDepthSelect.addEventListener('change', function() {
            if (!depthInfo) return;
            
            // Update information based on selected scan depth
            const selectedDepth = this.value;
            let infoText = '';
            
            switch(selectedDepth) {
                case 'basic':
                    infoText = 'Basic scan checks for common vulnerabilities and misconfigurations. Quick but may miss deeper issues.';
                    break;
                case 'standard':
                    infoText = 'Standard scan provides a balanced approach for most environments with reasonable scan time.';
                    break;
                case 'deep':
                    infoText = 'Deep scan performs comprehensive testing for vulnerabilities, but takes significantly longer to complete.';
                    break;
            }
            
            depthInfo.textContent = infoText;
        });
    }
    
    // Form submission handler with validation
    form.addEventListener('submit', function(e) {
        if (!validateVulnerabilityScanForm(form)) {
            e.preventDefault();
        } else {
            // Show loading state
            const submitButton = form.querySelector('button[type="submit"]');
            if (submitButton) {
                submitButton.disabled = true;
                submitButton.innerHTML = '<span class="loader"></span> Scanning...';
            }
            
            // Show processing message
            const processingMsg = document.getElementById('scan-processing-message');
            if (processingMsg) {
                processingMsg.style.display = 'block';
            }
        }
    });
}

// Validate vulnerability scan form
function validateVulnerabilityScanForm(form) {
    let isValid = true;
    
    // Check scan name
    const scanName = form.querySelector('#scan_name');
    if (scanName && (!scanName.value || scanName.value.trim() === '')) {
        displayFormError(scanName, 'Please enter a scan name');
        isValid = false;
    } else {
        clearFormError(scanName);
    }
    
    // Check target systems
    const targetSystems = form.querySelector('#target_systems');
    if (targetSystems && (!targetSystems.value || targetSystems.value.trim() === '')) {
        displayFormError(targetSystems, 'Please enter at least one target system');
        isValid = false;
    } else {
        clearFormError(targetSystems);
    }
    
    return isValid;
}

// Display form validation error
function displayFormError(element, message) {
    // Clear any existing error
    clearFormError(element);
    
    // Add error class to input
    element.classList.add('error');
    
    // Create and add error message
    const errorElement = document.createElement('div');
    errorElement.className = 'invalid-feedback';
    errorElement.textContent = message;
    
    // Insert error after the element
    element.parentNode.insertBefore(errorElement, element.nextSibling);
}

// Clear form validation error
function clearFormError(element) {
    element.classList.remove('error');
    
    // Remove any existing error message
    const errorElement = element.nextElementSibling;
    if (errorElement && errorElement.className === 'invalid-feedback') {
        errorElement.remove();
    }
}

// Initialize vulnerability management UI
function initVulnerabilityManagement() {
    // Status change buttons
    const statusButtons = document.querySelectorAll('.vuln-status-btn');
    
    statusButtons.forEach(button => {
        button.addEventListener('click', function() {
            const vulnId = this.getAttribute('data-vuln-id');
            const status = this.getAttribute('data-status');
            
            updateVulnerabilityStatus(vulnId, status);
        });
    });
    
    // Vulnerability details toggle
    const detailsToggles = document.querySelectorAll('.toggle-vuln-details');
    
    detailsToggles.forEach(toggle => {
        toggle.addEventListener('click', function(e) {
            e.preventDefault();
            
            const vulnId = this.getAttribute('data-vuln-id');
            const detailsPanel = document.querySelector(`.vuln-details[data-vuln-id="${vulnId}"]`);
            
            if (detailsPanel) {
                const isVisible = detailsPanel.classList.toggle('show');
                this.innerHTML = isVisible ? 
                    '<i class="fas fa-chevron-up"></i> Hide Details' : 
                    '<i class="fas fa-chevron-down"></i> Show Details';
            }
        });
    });
}

// Initialize vulnerability filters
function initVulnerabilityFilters() {
    const filterForm = document.getElementById('vulnerability-filter-form');
    if (!filterForm) return;
    
    // Severity filter
    const severityFilter = document.getElementById('severity-filter');
    if (severityFilter) {
        severityFilter.addEventListener('change', filterVulnerabilities);
    }
    
    // Status filter
    const statusFilter = document.getElementById('status-filter');
    if (statusFilter) {
        statusFilter.addEventListener('change', filterVulnerabilities);
    }
    
    // Search filter
    const searchInput = document.getElementById('vulnerability-search');
    if (searchInput) {
        searchInput.addEventListener('keyup', filterVulnerabilities);
    }
    
    // Initial filter application
    filterVulnerabilities();
}

// Filter vulnerabilities based on selected criteria
function filterVulnerabilities() {
    const severityFilter = document.getElementById('severity-filter');
    const statusFilter = document.getElementById('status-filter');
    const searchInput = document.getElementById('vulnerability-search');
    
    if (!severityFilter && !statusFilter && !searchInput) return;
    
    const selectedSeverity = severityFilter ? severityFilter.value : 'all';
    const selectedStatus = statusFilter ? statusFilter.value : 'all';
    const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
    
    const vulnItems = document.querySelectorAll('.vulnerability-item');
    let visibleCount = 0;
    
    vulnItems.forEach(item => {
        // Check severity filter
        const severityMatch = selectedSeverity === 'all' || 
                            item.getAttribute('data-severity') === selectedSeverity;
        
        // Check status filter
        const statusMatch = selectedStatus === 'all' || 
                          item.getAttribute('data-status') === selectedStatus;
        
        // Check search term
        const itemText = item.textContent.toLowerCase();
        const searchMatch = searchTerm === '' || itemText.includes(searchTerm);
        
        // Apply visibility
        if (severityMatch && statusMatch && searchMatch) {
            item.style.display = '';
            visibleCount++;
        } else {
            item.style.display = 'none';
        }
    });
    
    // Update results count
    const resultsCounter = document.getElementById('vuln-count');
    if (resultsCounter) {
        resultsCounter.textContent = visibleCount;
    }
    
    // Display "no results" message if needed
    const noResultsMessage = document.getElementById('no-vulns-message');
    if (noResultsMessage) {
        noResultsMessage.style.display = visibleCount === 0 ? 'block' : 'none';
    }
}

// Initialize vulnerability visualization
function initVulnerabilityVisualization() {
    const vulnerabilityMapElement = document.getElementById('vulnerability-map');
    if (!vulnerabilityMapElement) return;
    
    // Get vulnerability data
    const vulnerabilityItems = document.querySelectorAll('.vulnerability-item');
    const vulnerabilities = [];
    
    vulnerabilityItems.forEach(item => {
        vulnerabilities.push({
            severity: item.getAttribute('data-severity'),
            status: item.getAttribute('data-status'),
            system: item.getAttribute('data-system') || ''
        });
    });
    
    // Create vulnerability heat map
    createVulnerabilityHeatMap(vulnerabilityMapElement, vulnerabilities);
}

// Create a heat map visualization of vulnerabilities
function createVulnerabilityHeatMap(container, vulnerabilities) {
    // Clear container
    container.innerHTML = '';
    
    // Set container position to relative if not already
    if (window.getComputedStyle(container).position === 'static') {
        container.style.position = 'relative';
    }
    
    // Generate random positions for each vulnerability
    vulnerabilities.forEach((vuln, index) => {
        const heatPoint = document.createElement('div');
        heatPoint.className = 'vulnerability-heat';
        
        // Set position
        const left = Math.random() * 80 + 10; // 10-90%
        const top = Math.random() * 80 + 10;  // 10-90%
        
        heatPoint.style.left = `${left}%`;
        heatPoint.style.top = `${top}%`;
        
        // Set size and color based on severity
        let size, color, opacity;
        
        switch(vuln.severity) {
            case 'critical':
                size = '120px';
                color = 'rgba(255, 56, 96, 0.8)';
                opacity = 0.8;
                break;
            case 'high':
                size = '100px';
                color = 'rgba(255, 157, 68, 0.7)';
                opacity = 0.7;
                break;
            case 'medium':
                size = '80px';
                color = 'rgba(255, 221, 87, 0.6)';
                opacity = 0.6;
                break;
            case 'low':
                size = '60px';
                color = 'rgba(72, 199, 116, 0.5)';
                opacity = 0.5;
                break;
            default:
                size = '80px';
                color = 'rgba(137, 87, 229, 0.6)';
                opacity = 0.6;
        }
        
        // Reduce opacity for resolved vulnerabilities
        if (vuln.status === 'resolved' || vuln.status === 'false_positive') {
            opacity *= 0.3;
        }
        
        heatPoint.style.width = size;
        heatPoint.style.height = size;
        heatPoint.style.marginLeft = `-${parseInt(size) / 2}px`;
        heatPoint.style.marginTop = `-${parseInt(size) / 2}px`;
        heatPoint.style.background = color;
        heatPoint.style.opacity = opacity;
        
        // Add tooltip with system info if available
        if (vuln.system) {
            heatPoint.setAttribute('data-tooltip', `System: ${vuln.system}`);
        }
        
        container.appendChild(heatPoint);
    });
    
    // Add legend
    const legend = document.createElement('div');
    legend.className = 'vulnerability-map-legend';
    legend.innerHTML = `
        <div class="legend-item">
            <span class="legend-color" style="background: rgba(255, 56, 96, 0.8)"></span>
            <span class="legend-label">Critical</span>
        </div>
        <div class="legend-item">
            <span class="legend-color" style="background: rgba(255, 157, 68, 0.7)"></span>
            <span class="legend-label">High</span>
        </div>
        <div class="legend-item">
            <span class="legend-color" style="background: rgba(255, 221, 87, 0.6)"></span>
            <span class="legend-label">Medium</span>
        </div>
        <div class="legend-item">
            <span class="legend-color" style="background: rgba(72, 199, 116, 0.5)"></span>
            <span class="legend-label">Low</span>
        </div>
    `;
    
    container.appendChild(legend);
}

// Create remediation plan for vulnerability
function createRemediationPlan(vulnId) {
    const vulnItem = document.querySelector(`.vulnerability-item[data-vuln-id="${vulnId}"]`);
    if (!vulnItem) return;
    
    const vulnName = vulnItem.querySelector('.vulnerability-name')?.textContent || 'Selected vulnerability';
    const vulnSeverity = vulnItem.getAttribute('data-severity') || 'medium';
    
    // Show modal (assuming Bootstrap or similar library)
    const modal = document.getElementById('remediation-modal');
    if (modal) {
        const modalTitle = modal.querySelector('.modal-title');
        const modalForm = modal.querySelector('#remediation-form');
        
        if (modalTitle) {
            modalTitle.textContent = `Remediation Plan: ${vulnName}`;
        }
        
        if (modalForm) {
            // Set vulnerability ID in hidden field
            const vulnIdInput = modalForm.querySelector('#remediation_vuln_id');
            if (vulnIdInput) {
                vulnIdInput.value = vulnId;
            }
            
            // Set suggested timeline based on severity
            const timelineSelect = modalForm.querySelector('#remediation_timeline');
            if (timelineSelect) {
                let suggestedTimeline;
                
                switch(vulnSeverity) {
                    case 'critical':
                        suggestedTimeline = 'immediate';
                        break;
                    case 'high':
                        suggestedTimeline = '1week';
                        break;
                    case 'medium':
                        suggestedTimeline = '2weeks';
                        break;
                    case 'low':
                        suggestedTimeline = '1month';
                        break;
                    default:
                        suggestedTimeline = '2weeks';
                }
                
                timelineSelect.value = suggestedTimeline;
            }
        }
        
        // Show the modal (using Bootstrap's modal or custom code)
        $('#remediation-modal').modal('show');
    }
}

// Export vulnerability report
function exportVulnerabilityReport(format) {
    // Show loading indicator
    const exportBtn = document.querySelector(`.export-${format}-btn`);
    if (exportBtn) {
        exportBtn.disabled = true;
        exportBtn.innerHTML = `<span class="loader"></span> Exporting...`;
    }
    
    // In a real implementation, this would call an API endpoint
    // For now, we'll just simulate the process
    setTimeout(() => {
        // Reset button
        if (exportBtn) {
            exportBtn.disabled = false;
            exportBtn.innerHTML = `<i class="fas fa-file-${format}"></i> Export ${format.toUpperCase()}`;
        }
        
        // Show success message
        const messageContainer = document.getElementById('message-container');
        if (messageContainer) {
            messageContainer.innerHTML = `
                <div class="alert alert-success">
                    <i class="fas fa-check-circle"></i> Vulnerability report exported successfully as ${format.toUpperCase()}.
                </div>
            `;
            
            setTimeout(() => {
                messageContainer.innerHTML = '';
            }, 3000);
        }
    }, 1500);
}

// Vulnerability Scan Simulator for demonstration
class VulnerabilityScanSimulator {
    constructor(containerId, options = {}) {
        this.container = document.getElementById(containerId);
        if (!this.container) return;
        
        this.options = Object.assign({
            scanDuration: 30, // seconds
            vulnCount: { min: 3, max: 8 },
            showProgressBar: true
        }, options);
        
        this.isScanning = false;
        this.progress = 0;
        this.interval = null;
        this.vulnerabilities = [];
        
        this.init();
    }
    
    init() {
        // Create UI elements
        this.createUI();
        
        // Add event listeners
        const startButton = this.container.querySelector('.start-scan-btn');
        if (startButton) {
            startButton.addEventListener('click', () => this.startScan());
        }
    }
    
    createUI() {
        this.container.innerHTML = `
            <div class="scan-simulator-controls mb-3">
                <button class="btn btn-primary start-scan-btn">Start Demo Scan</button>
            </div>
            <div class="scan-simulator-progress" style="display: none;">
                <div class="progress mb-2">
                    <div class="progress-bar" role="progressbar" style="width: 0%"></div>
                </div>
                <div class="scan-status">Ready to scan...</div>
            </div>
            <div class="scan-simulator-results mt-3" style="display: none;">
                <h4>Scan Results</h4>
                <div class="vulnerability-list"></div>
            </div>
        `;
        
        this.progressContainer = this.container.querySelector('.scan-simulator-progress');
        this.progressBar = this.container.querySelector('.progress-bar');
        this.statusText = this.container.querySelector('.scan-status');
        this.resultsContainer = this.container.querySelector('.scan-simulator-results');
        this.vulnerabilityList = this.container.querySelector('.vulnerability-list');
    }
    
    startScan() {
        if (this.isScanning) return;
        
        this.isScanning = true;
        this.progress = 0;
        this.vulnerabilities = [];
        
        // Show progress area
        this.progressContainer.style.display = 'block';
        this.resultsContainer.style.display = 'none';
        this.vulnerabilityList.innerHTML = '';
        
        // Update status
        this.statusText.textContent = 'Initializing scan...';
        
        // Generate a random number of vulnerabilities
        const vulnCount = Math.floor(Math.random() * 
            (this.options.vulnCount.max - this.options.vulnCount.min + 1)) + 
            this.options.vulnCount.min;
        
        // Generate vulnerability data
        this.generateVulnerabilities(vulnCount);
        
        // Start progress updates
        const updateInterval = this.options.scanDuration * 1000 / 100; // Update every 1% of duration
        this.interval = setInterval(() => this.updateProgress(), updateInterval);
        
        // Simulate scan completion
        setTimeout(() => this.completeScan(), this.options.scanDuration * 1000);
    }
    
    updateProgress() {
        this.progress += 1;
        this.progressBar.style.width = `${this.progress}%`;
        
        // Update status messages at certain points
        if (this.progress === 10) {
            this.statusText.textContent = 'Scanning network ports...';
        } else if (this.progress === 30) {
            this.statusText.textContent = 'Checking system configurations...';
        } else if (this.progress === 50) {
            this.statusText.textContent = 'Analyzing service versions...';
        } else if (this.progress === 70) {
            this.statusText.textContent = 'Identifying potential vulnerabilities...';
        } else if (this.progress === 90) {
            this.statusText.textContent = 'Generating report...';
        }
        
        // Reveal vulnerabilities progressively
        const vulnToReveal = Math.floor(this.vulnerabilities.length * (this.progress / 100));
        
        // Show vulnerabilities if we've revealed any new ones
        if (vulnToReveal > this.vulnerabilityList.children.length) {
            this.renderVulnerabilities(vulnToReveal);
        }
    }
    
    completeScan() {
        clearInterval(this.interval);
        this.isScanning = false;
        
        // Ensure progress is at 100%
        this.progress = 100;
        this.progressBar.style.width = '100%';
        this.statusText.textContent = 'Scan completed successfully';
        
        // Show all vulnerabilities
        this.renderVulnerabilities(this.vulnerabilities.length);
        this.resultsContainer.style.display = 'block';
        
        // Display summary
        const summaryElement = document.createElement('div');
        summaryElement.className = 'scan-summary mt-3 card p-3';
        
        // Count vulnerabilities by severity
        const severityCounts = {
            critical: 0,
            high: 0,
            medium: 0,
            low: 0
        };
        
        this.vulnerabilities.forEach(vuln => {
            severityCounts[vuln.severity]++;
        });
        
        summaryElement.innerHTML = `
            <h5>Scan Summary</h5>
            <div class="d-flex justify-content-between">
                <div class="summary-item">
                    <span class="badge badge-critical">${severityCounts.critical}</span>
                    <span>Critical</span>
                </div>
                <div class="summary-item">
                    <span class="badge badge-high">${severityCounts.high}</span>
                    <span>High</span>
                </div>
                <div class="summary-item">
                    <span class="badge badge-medium">${severityCounts.medium}</span>
                    <span>Medium</span>
                </div>
                <div class="summary-item">
                    <span class="badge badge-low">${severityCounts.low}</span>
                    <span>Low</span>
                </div>
            </div>
        `;
        
        this.vulnerabilityList.insertAdjacentElement('beforebegin', summaryElement);
    }
    
    generateVulnerabilities(count) {
        const commonVulnerabilities = [
            { name: 'Outdated OpenSSL Library', description: 'An outdated version of OpenSSL was detected which contains known vulnerabilities.', severity: 'critical' },
            { name: 'SSH Weak Cipher Algorithms', description: 'The SSH server is configured to allow weak cipher algorithms that can be easily compromised.', severity: 'high' },
            { name: 'Default SNMP Community Strings', description: 'The device is using default SNMP community strings which can be easily guessed.', severity: 'high' },
            { name: 'Outdated Web Server', description: 'The web server software is running an outdated version with known security issues.', severity: 'medium' },
            { name: 'Missing HTTP Security Headers', description: 'Important security headers such as Content-Security-Policy are not implemented.', severity: 'medium' },
            { name: 'Insecure Cookies Configuration', description: 'Cookies are transmitted without the secure flag set, making them vulnerable to interception.', severity: 'medium' },
            { name: 'Verbose Error Messages', description: 'Application returns verbose error messages that may reveal sensitive information.', severity: 'low' },
            { name: 'Exposed .git Repository', description: '.git directory is accessible, potentially exposing source code and sensitive information.', severity: 'high' },
            { name: 'Open NTP Server', description: 'NTP server is configured to respond to mode 6 queries from any host, which can be abused for DDoS amplification.', severity: 'medium' },
            { name: 'Cross-Site Scripting (XSS)', description: 'Application is vulnerable to cross-site scripting attacks due to improper input validation.', severity: 'high' },
            { name: 'SQL Injection Vulnerability', description: 'Application is vulnerable to SQL injection attacks, allowing potential unauthorized access to the database.', severity: 'critical' },
            { name: 'Unpatched Operating System', description: 'Operating system is missing critical security patches that address known vulnerabilities.', severity: 'high' }
        ];
        
        // Generate random vulnerabilities
        for (let i = 0; i < count; i++) {
            // Select a random vulnerability from the common ones
            const vulnTemplate = commonVulnerabilities[Math.floor(Math.random() * commonVulnerabilities.length)];
            
            // Generate a random IP for the affected system
            const ip = `192.168.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`;
            
            // Add to vulnerabilities list with unique ID
            this.vulnerabilities.push({
                id: i + 1,
                name: vulnTemplate.name,
                description: vulnTemplate.description,
                severity: vulnTemplate.severity,
                affected_system: ip,
                discovery_date: new Date().toISOString().split('T')[0]
            });
        }
    }
    
    renderVulnerabilities(count) {
        // Clear the list first
        this.vulnerabilityList.innerHTML = '';
        
        // Render the vulnerabilities
        for (let i = 0; i < count; i++) {
            const vuln = this.vulnerabilities[i];
            const vulnElement = document.createElement('div');
            vulnElement.className = `vulnerability-item mb-2 p-3 border-left-${vuln.severity}`;
            
            vulnElement.innerHTML = `
                <div class="d-flex justify-content-between align-items-center">
                    <h5 class="vulnerability-name mb-1">${vuln.name}</h5>
                    <span class="badge badge-${vuln.severity}">${vuln.severity.toUpperCase()}</span>
                </div>
                <div class="vulnerability-description mb-2">${vuln.description}</div>
                <div class="vulnerability-meta">
                    <small>Affected System: ${vuln.affected_system}</small>
                    <small class="ml-3">Discovered: ${vuln.discovery_date}</small>
                </div>
            `;
            
            this.vulnerabilityList.appendChild(vulnElement);
            
            // Add animation for newly added items
            vulnElement.classList.add('fade-in');
        }
    }
}
