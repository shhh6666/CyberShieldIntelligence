import random
import logging
import time
from datetime import datetime
import ipaddress
import re

logger = logging.getLogger(__name__)

# Common vulnerability data for simulation purposes
COMMON_VULNERABILITIES = [
    {
        'name': 'CVE-2021-44228 (Log4Shell)',
        'description': 'Critical remote code execution vulnerability in Apache Log4j library',
        'severity': 'critical',
        'cve_id': 'CVE-2021-44228',
        'remediation_steps': 'Update Log4j to version 2.15.0 or higher, or implement recommended mitigations.'
    },
    {
        'name': 'SQL Injection Vulnerability',
        'description': 'Application is vulnerable to SQL injection attacks, allowing potential data exfiltration',
        'severity': 'high',
        'cve_id': '',
        'remediation_steps': 'Implement prepared statements or parameterized queries, and input validation.'
    },
    {
        'name': 'Outdated SSL/TLS Version',
        'description': 'Server supports outdated SSL/TLS protocols (TLS 1.0/1.1) that have known vulnerabilities',
        'severity': 'medium',
        'cve_id': '',
        'remediation_steps': 'Configure servers to only support TLS 1.2 or higher.'
    },
    {
        'name': 'Default Credentials',
        'description': 'System is using default or weak credentials for administrative access',
        'severity': 'high',
        'cve_id': '',
        'remediation_steps': 'Change default passwords, implement strong password policies, and use MFA where possible.'
    },
    {
        'name': 'Exposed Sensitive Files',
        'description': 'Sensitive configuration files or directories are accessible without authentication',
        'severity': 'medium',
        'cve_id': '',
        'remediation_steps': 'Review and restrict access to configuration files and implement proper access controls.'
    },
    {
        'name': 'Open Unnecessary Ports',
        'description': 'Multiple unnecessary network ports are open, increasing attack surface',
        'severity': 'medium',
        'cve_id': '',
        'remediation_steps': 'Close unnecessary ports and implement network segmentation.'
    },
    {
        'name': 'CVE-2023-23397 (Microsoft Outlook Elevation of Privilege)',
        'description': 'A vulnerability in Microsoft Outlook that could allow attackers to leak NTLM hashes',
        'severity': 'critical',
        'cve_id': 'CVE-2023-23397',
        'remediation_steps': 'Apply the latest Microsoft security updates for Outlook.'
    },
    {
        'name': 'Outdated Software Versions',
        'description': 'Multiple services running outdated software versions with known vulnerabilities',
        'severity': 'high',
        'cve_id': '',
        'remediation_steps': 'Implement a regular patching schedule and update all software to the latest versions.'
    },
    {
        'name': 'Weak Encryption',
        'description': 'System uses weak or outdated encryption algorithms',
        'severity': 'medium',
        'cve_id': '',
        'remediation_steps': 'Update to strong encryption algorithms (AES-256, RSA-2048 or higher) and secure protocols.'
    },
    {
        'name': 'Missing Security Headers',
        'description': 'Web application missing important security headers (HSTS, CSP, X-XSS-Protection)',
        'severity': 'low',
        'cve_id': '',
        'remediation_steps': 'Implement recommended security headers for all web applications.'
    },
    {
        'name': 'Insecure File Permissions',
        'description': 'Critical system files have overly permissive access rights',
        'severity': 'medium',
        'cve_id': '',
        'remediation_steps': 'Review and restrict file permissions following the principle of least privilege.'
    }
]

def scan_for_vulnerabilities(target_systems, scan_depth='standard'):
    """
    Simulate scanning systems for vulnerabilities.
    
    Args:
        target_systems (list): List of IP addresses or hostnames to scan
        scan_depth (str): Scan depth ('basic', 'standard', 'deep')
        
    Returns:
        list: Detected vulnerabilities
    """
    logger.info(f"Starting vulnerability scan on {len(target_systems)} targets with {scan_depth} depth")
    
    # Validate target systems
    validated_targets = []
    for target in target_systems:
        target = target.strip()
        try:
            # Check if it's a valid IP address
            ipaddress.ip_address(target)
            validated_targets.append(target)
        except ValueError:
            # Not an IP address, check if it's a hostname
            if re.match(r'^[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*$', target):
                validated_targets.append(target)
            else:
                logger.warning(f"Invalid target skipped: {target}")
    
    if not validated_targets:
        logger.error("No valid targets to scan")
        return []
    
    # Determine number of vulnerabilities based on scan depth
    vulnerabilities_per_target = {
        'basic': (0, 3),
        'standard': (1, 5),
        'deep': (2, 8)
    }
    
    min_vulns, max_vulns = vulnerabilities_per_target.get(scan_depth, (1, 4))
    
    # Scan each target
    results = []
    for target in validated_targets:
        # Simulate scan time based on depth
        scan_times = {'basic': 1, 'standard': 2, 'deep': 3}
        time.sleep(scan_times.get(scan_depth, 1) * 0.1)  # Reduced for demonstration
        
        # Randomly select vulnerabilities for this target
        num_vulnerabilities = random.randint(min_vulns, max_vulns)
        selected_vulnerabilities = random.sample(
            COMMON_VULNERABILITIES, 
            min(num_vulnerabilities, len(COMMON_VULNERABILITIES))
        )
        
        # Add target information to each vulnerability
        for vuln in selected_vulnerabilities:
            vuln_copy = vuln.copy()
            vuln_copy['affected_system'] = target
            results.append(vuln_copy)
    
    logger.info(f"Vulnerability scan completed. Found {len(results)} vulnerabilities.")
    return results

def classify_vulnerability_severity(vuln_data):
    """
    Classify the severity of a vulnerability based on various factors.
    
    Args:
        vuln_data (dict): Vulnerability data
        
    Returns:
        str: Severity classification ('critical', 'high', 'medium', 'low')
    """
    # This would normally use CVSS scores or similar standardized metrics
    # For simulation, we use simple keyword matching
    description = vuln_data.get('description', '').lower()
    
    if any(kw in description for kw in ['remote code execution', 'rce', 'critical', 'authentication bypass']):
        return 'critical'
    elif any(kw in description for kw in ['sql injection', 'xss', 'privilege escalation', 'data breach', 'ransomware']):
        return 'high'
    elif any(kw in description for kw in ['outdated', 'misconfiguration', 'weak passwords', 'information disclosure']):
        return 'medium'
    else:
        return 'low'
